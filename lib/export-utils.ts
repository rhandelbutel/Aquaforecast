// lib/export-utils.ts
"use client";

import { toPng } from "html-to-image";
import jsPDF from "jspdf";

export type ExportTarget = {
  id: string;
  title: string;
  label?: string;
};

type FooterInfo = {
  email?: string | null;
};

export async function captureById(
  id: string,
  options: { width?: number; height?: number } = {} // <-- This is the updated part
): Promise<string | null> {
  const el = document.getElementById(id);
  if (!el) return null;
  el.scrollIntoView({ block: "nearest" });
  await new Promise((r) => setTimeout(r, 50));
  try {
    const dataUrl = await toPng(el, {
      pixelRatio: 2,
      cacheBust: true,
      backgroundColor: "#ffffff",
      skipFonts: false,
      ...options, // <-- This is the updated part
    });
    return dataUrl;
  } catch (e) {
    console.error("captureById error", e);
    return null;
  }
}


// --------- Multi-page ----------
export async function buildPdfFromImages(opts: {
  images: Array<{ title: string; dataUrl: string }>;
  fileName: string;
  footer?: FooterInfo;
  headerBrand?: string;
}) {
  const pdf = new jsPDF({ orientation: "p", unit: "pt", format: "a4" });
  const pageW = pdf.internal.pageSize.getWidth();
  const pageH = pdf.internal.pageSize.getHeight();

  const margin = 28;
  const headerH = 26;

  const addHeader = () => {
    const brand = (opts.headerBrand ?? "").trim();
    if (!brand) return;
    pdf.setFontSize(14);
    pdf.setTextColor(20);
    pdf.text(brand, pageW / 2, margin + 8, { align: "center" });
    pdf.setDrawColor(230);
    pdf.line(margin, margin + 14, pageW - margin, margin + 14);
    pdf.setTextColor(0);
  };

  const addFooter = () => {
    const nowStr = new Date().toLocaleString("en-PH", {
      year: "numeric",
      month: "long",
      day: "numeric",
      hour: "2-digit",
      minute: "2-digit",
      hour12: true,
    });
    const who = opts.footer?.email ? ` • Generated by ${opts.footer.email}` : "";
    pdf.setFontSize(10);
    pdf.setTextColor(100);
    pdf.text(`Generated on ${nowStr}${who}`, margin, pageH - 20);
    pdf.setTextColor(0);
  };

  const addPageWith = (title: string, dataUrl: string, isFirst: boolean) => {
    if (!isFirst) pdf.addPage();
    addHeader();

    if (title) {
      pdf.setFontSize(12);
      pdf.text(title, margin, margin + 30);
    }

    const topOffset = title ? 44 : 26;
    const maxW = pageW - margin * 2;
    const maxH = pageH - margin * 2 - topOffset;

    const img = new Image();
    img.src = dataUrl;
    const ratio = img.width && img.height ? img.width / img.height : 1.6;

    let w = maxW;
    let h = w / ratio;
    if (h > maxH) {
      h = maxH;
      w = h * ratio;
    }

    const x = margin + (maxW - w) / 2;
    const y = margin + topOffset + (maxH - h) / 2;
    pdf.addImage(dataUrl, "PNG", x, y, w, h, undefined, "FAST");

    addFooter();
  };

  opts.images.forEach((img, i) => addPageWith(img.title, img.dataUrl, i === 0));
  pdf.save(opts.fileName);
}

// --------- Single page (stacks, no stretch) ----------
async function getImgSize(dataUrl: string): Promise<{ w: number; h: number }> {
  return new Promise((resolve) => {
    const img = new Image();
    img.onload = () => resolve({ w: img.naturalWidth || img.width, h: img.naturalHeight || img.height });
    img.src = dataUrl;
  });
}

export async function buildPdfSinglePageFromImages(opts: {
  images: Array<{ title: string; dataUrl: string }>;
  fileName: string;
  footer?: FooterInfo;
  headerBrand?: string;
}) {
  const pdf = new jsPDF({ orientation: "p", unit: "pt", format: "a4" });
  const pageW = pdf.internal.pageSize.getWidth();
  const pageH = pdf.internal.pageSize.getHeight();

  const margin = 28;
  const headerH = 30;
  const gutter = 8;

  const addHeader = () => {
    const brand = (opts.headerBrand ?? "").trim();
    if (!brand) return;
    pdf.setFontSize(14);
    pdf.setTextColor(20);
    pdf.text(brand, pageW / 2, margin + 10, { align: "center" });
    pdf.setDrawColor(230);
    pdf.line(margin, margin + 16, pageW - margin, margin + 16);
    pdf.setTextColor(0);
  };

  addHeader();

  const maxW = pageW - margin * 2;
  const maxH = pageH - margin * 2 - headerH - 20;

  const measured = await Promise.all(
    opts.images.map(async (img) => {
      const sz = await getImgSize(img.dataUrl);
      const ratio = sz.w / sz.h || 1.6;
      const targetH = maxW / ratio;
      return { ...img, ratio, baseW: maxW, baseH: targetH };
    })
  );

  const totalH = measured.reduce((sum, m, i) => sum + m.baseH + (i ? gutter : 0), 0);
  const scale = totalH > maxH ? maxH / totalH : 1;

  let y = margin + headerH;
  measured.forEach((m) => {
    const w = m.baseW * scale;
    const h = m.baseH * scale;
    const x = margin + (maxW - w) / 2;

    if (m.title) {
      pdf.setFontSize(10);
      pdf.setTextColor(90);
      pdf.text(m.title, margin, y - 4);
      pdf.setTextColor(0);
    }

    pdf.addImage(m.dataUrl, "PNG", x, y, w, h, undefined, "FAST");
    y += h + gutter;
  });

  const nowStr = new Date().toLocaleString("en-PH", {
    year: "numeric",
    month: "long",
    day: "numeric",
    hour: "2-digit",
    minute: "2-digit",
    hour12: true,
  });
  const who = opts.footer?.email ? ` • Generated by ${opts.footer.email}` : "";
  pdf.setFontSize(10);
  pdf.setTextColor(100);
  pdf.text(`Generated on ${nowStr}${who}`, margin, pageH - 20);
  pdf.setTextColor(0);

  pdf.save(opts.fileName);
}

export function makeDefaultTargets(): ExportTarget[] {
  return [
    { id: "export-pond-summary", title: "", label: "Pond Summary" },
    { id: "export-realtime",     title: "", label: "Real-time Sensor Data" },
    { id: "export-harvest",      title: "", label: "Harvest Prediction" },
    { id: "export-alerts",       title: "", label: "System Alerts" },
  ];
}

export function niceNow() {
  const d = new Date();
  const pad = (n: number) => String(n).padStart(2, "0");
  return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}_${pad(d.getHours())}-${pad(d.getMinutes())}`;
}